00000            prog          START   0    
                  
                  . Input example: "10010\n0010\n0100\n0"
00000  4B2072    fact          JSUB    stackinit    
                  
00003  B450      readNex       CLEAR   T    
                  . read data from dev
00005  B400      read          CLEAR   A    
00007  DB213A                  RD      inDev    
                  . check for newline
0000A  2B21CC                  COMP    *0 (WORD 13)    . in windows newline is \r = 13
                  . jump if A != \r and check for \n
0000D  372006                  JGT     checkNL    
00010  3B2003                  JLT     checkNL    
00013  DB212E                  RD      inDev    
00016  2B21C3    checkNL       COMP    *1 (WORD 10)    . if newline
00019  33200D                  JEQ     endRead    
0001C  1F21C0    readmid       SUB     *2 (WORD 48)    . subtract '0'
0001F  9050                    ADDR    T,A    
00021  2321BE                  MUL     *3 (WORD 2)    . we are reading binary
00024  AC05                    RMO     A,T    
00026  3F2FDC                  J       read    
                  
00029  AC50      endRead       RMO     T,A    
0002B  2B21B7                  COMP    *4 (WORD 0)    . if zero
0002E  332015                  JEQ     halt    
00031  2721AE                  DIV     *3 (WORD 2)    . last iteration multiplied by 2
00034  4B210E                  JSUB    echonum    . print current number
                  . print "! = "
00037  4B216D                  JSUB    echoFactEq    
                  . calculate factorial
0003A  4B200C                  JSUB    factorial    
                  . output caluculated factorial
0003D  4B2105                  JSUB    echonum    
00040  4B214F                  JSUB    echoln    
00043  3F2FBD                  J       readNex    
00046  3F2FFD    halt          J       halt    
                  
                  ....... CACLULATOR .........
00049  2B219C    factorial     COMP    *5 (WORD 1)    
0004C  372003                  JGT     factrec    
0004F  4F0000                  RSUB        . return if A == 1
00052  162056    factrec       STL     @stackptr    . store L to stack
00055  4B202C                  JSUB    stackpush    
00058  0E2050                  STA     @stackptr    . store A to stack
0005B  4B2026                  JSUB    stackpush    
                  
                  . calulate for smaller problem
0005E  1F2187                  SUB     *5 (WORD 1)    . n -> n-1 problem reduction
00061  4B2FE5                  JSUB    factorial    . calculate for n-1
                  
00064  4B202F                  JSUB    stackpop    
00067  762041                  LDT     @stackptr    . set T to current iterartion problem
0006A  4B2029                  JSUB    stackpop    
0006D  0A203B                  LDL     @stackptr    . load L from stack
                  
                  . calculate current iteration factorial
00070  9850                    MULR    T,A    
00072  4F0000                  RSUB        
                  
00075  0F2030    stackinit     STA     stacktmp    
                  
                  . init stackptr value
00078  012033                  LDA     #stack    
0007B  0F202D                  STA     stackptr    
                  
                  . restore values
0007E  032027                  LDA     stacktmp    
00081  4F0000                  RSUB        
                  
00084  0F2021    stackpush     STA     stacktmp    
                  
                  . move pointer up
00087  032021                  LDA     stackptr    
0008A  1B215E                  ADD     *6 (WORD 3)    
0008D  0F201B                  STA     stackptr    
                  
                  . restore values
00090  032015                  LDA     stacktmp    
00093  4F0000                  RSUB        
                  
00096  0F200F    stackpop      STA     stacktmp    
                  
                  . move pointer down
00099  03200F                  LDA     stackptr    
0009C  1F214C                  SUB     *6 (WORD 3)    
0009F  0F2009                  STA     stackptr    
                  
                  . restore values
000A2  032003                  LDA     stacktmp    
000A5  4F0000                  RSUB        
                  
000A8  000000    stacktmp      WORD    0    
000AB  000000    stackptr      WORD    0    
000AE  00....00  stack         RESW    50    
                  
00144  FA        inDev         BYTE    X'FA'    
                  
                  ..................... Number print .......................
00145  872080    echonum       STT     tmp    . this subroutine uses T - store it and restore it in the end
00148  0F207E                  STA     tmp2    
0014B  052083                  LDX     #numDec    
0014E  13207C                  STX     next    . next is pointer to where to store data
                  . each iteration gets last decimal from A and stores it in numDec
00151  AC05      numLoop       RMO     A,T    . T = A
00153  272086                  DIV     *1 (WORD 10)    
00156  AC04                    RMO     A,S    . S = A //store A in S to use in next iter
00158  232081                  MUL     *1 (WORD 10)    
0015B  9405                    SUBR    A,T    . T = T - A
0015D  AC50                    RMO     T,A    . A = T
0015F  56206B                  STCH    @next    . store last decimal place
                  . increment next location
00162  2F2080                  TIX     *4 (WORD 0)    
00165  132065                  STX     next    
                  . check if this was last decimal
00168  AC40                    RMO     S,A    . A = S // load A/10 into A and use it in next iteration
0016A  2B2078                  COMP    *4 (WORD 0)    
0016D  372FE1                  JGT     numLoop    
00170  6F2075                  LDS     *5 (WORD 1)    
00173  75205B                  LDT     #numDec    
00176  9441      numLoopPrint  SUBR    S,X    
00178  132052                  STX     next    
                  . print next
0017B  52204F                  LDCH    @next    
0017E  1B205E                  ADD     *2 (WORD 48)    . 60 = 0 in ASCII
00181  DF204C                  WD      stdout    
00184  A051                    COMPR   T,X    
00186  3B2FED                  JLT     numLoopPrint    
                  
00189  77203C                  LDT     tmp    
0018C  03203A                  LDA     tmp2    
0018F  4F0000                  RSUB        
                  
                  . print \n
00192  572033    echoln        STCH    tmp    
00195  532034                  LDCH    newline    
00198  17202E                  STL     tmp2    
0019B  DF2032                  WD      stdout    
0019E  0B2028                  LDL     tmp2    
001A1  532024                  LDCH    tmp    
001A4  4F0000                  RSUB        
                  
001A7  0F201E    echoFactEq    STA     tmp    
001AA  032041                  LDA     *7 (WORD 33)    
001AD  DF2020                  WD      stdout    
001B0  03203E                  LDA     *8 (WORD 32)    
001B3  DF201A                  WD      stdout    
001B6  03203B                  LDA     *9 (WORD 61)    
001B9  DF2014                  WD      stdout    
001BC  032032                  LDA     *8 (WORD 32)    
001BF  DF200E                  WD      stdout    
001C2  032003                  LDA     tmp    
001C5  4F0000                  RSUB        
                  
001C8  00        tmp           BYTE    0    
001C9  000000    tmp2          WORD    0    
001CC  0A        newline       BYTE    X'0A'    
                  
                  
001CD  000000    next          WORD    0    
001D0  01        stdout        BYTE    X'01'    
                  
001D1  00....00  numDec        RESB    8    . 16777215 is max -> at most 8 decimal places
001D9  00000D    *0            WORD    13    
001DC  00000A    *1            WORD    10    
001DF  000030    *2            WORD    48    
001E2  000002    *3            WORD    2    
001E5  000000    *4            WORD    0    
001E8  000001    *5            WORD    1    
001EB  000003    *6            WORD    3    
001EE  000021    *7            WORD    33    
001F1  000020    *8            WORD    32    
001F4  00003D    *9            WORD    61    
